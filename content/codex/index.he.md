---
title: "הסיפור על מל"
moto: "פורסם בידי מחברו, אד ניית׳ר <nather@astro.as.utexas.edu>, ברשת Usenet, ב-21 במאי 1983."
author: "אד ניית׳ר"
credits: "תרגם מאנגלית וביאר: תומר ליכטש | ייעוץ מדעי: דוד פרנקל"
---

מאמר מן הזמן האחרון על צד _מצ'ואיסטי_ בתכנות[(#recent-article)]
יצא בהכרזה נועזת וחסרת בסיס:

> "[מתכנתים אמיתיים](#real-programmer) כותבים ב[פוֹרְטְרַן](#fortran)"

אולי כיום,
בתקופה דקדנטית זו של
בירה לייט, מחשבוני כיס[(#calculators)], ותוכנה ["ידידותית-למשתמש"](#)[(#user-friendly-quatations)]
אך בימים ההם[(#story-timeline-estimation)],
כשהמונח "תוכנה" עוד היה נשמע מצחיק,
ומחשבים אמיתיים[(#real-computers)] נבנו ב[תופים](#) וב[שפופרות](#),
מתכנתים אמיתיים כתבו ב[שפת מכונה](#).
לא [פוֹרְטְרַן](#). לא [ראטפוֹר](#). אפילו לא [שפת סף](#).
שפת מכונה.
מספרים גולמיים ויפים ב[בסיס הקסדצימלי](#).
ישירות.

לבל יגדל דור מתכנתים חדש
בּוּר במורשת מפוארת זו
אני חש כי מחובתי לתאר
כמיטב יכולתי מבעד לפער הדורות
איך מתכנת אמיתי כתב קוד.
אקרא לו מֵל,
כי זה היה שמו.[(#mel-kaye-bio)]

את מל פגשתי כשעבדתי בחברת המחשבים רוֹיאל-מֶק'בִּי[(#the-timeline-of-royal-mcbee)],
כיום ישות רפאים עסקית המייצרת מכונת כתיבה.[(#the-ghost-of-royal-mcbee)]
החברה ייצרה אז את ה-[30-LGP](#),
מחשב קטן וזול (בסטנדרטים של היום)
בעל [זיכרון תוף](#),
ובדיוק החלה בייצור
ה-[4000-RPC](#), מחשב מתקדם יותר,
גדול יותר, טוב יותר, מהיר יותר – בעל [זיכרון תוף](#).
[ליבּוֹת זיכרון](#) היו יקרות מדי,
ובכל אופן, עמדו להעלם.
(זו הסיבה שלא שמעת על החברה,
או על המחשב.)

נשׂכרתי לכתוב [מְהַדֵּר](#) [פוֹרְטְרַן](#)
עבור הפֶּלא[(#librazette-marvell)] החדש הזה ומל היה המדריך שלי לכל נפלאותיו.
מל תיעב מהדרים.

"אם תוכנה לא יודעת לשכתב את הקוד של עצמה,"
שאל, "למה היא טובה?"

מל כתב,[(#handwritten-code)]
במספרים [הקסדצימליים](#),
את תוכנת הדגל של החברה.
היא רצה על ה-30-LGP
ושיחקה בלאק ג'ק בתערוכות מחשבים
עם לקוחות פוטנציאליים.[(#librazette-chicago-automation-show)]
התגובות שעוררה תמיד היו דרמטיות.[(#librazette-quote-1)]
בכל תערוכה היה ביתן ה-30-LGP עמוס,[(#librazette-quote-2)]
סביב התגודדו אנשי המכירות של IBM
ודיברו ביניהם.[(#librazette-quote-3)]
אם כל זה מכר מחשבים או לא
זו היתה שאלה שמעולם לא שאלנו.

העבודה של מל היתה לשכתב
את תוכנת הבלאק ג'ק עבור ה-4000-RPC.[(#mels-blackjack-game)]
(מי בכלל ידע אז מה זה [פּוֹרְט](#)?)
[מִיעוּן הכְּתוֹבוֹת](#)[(#instruction1)] במחשב החדש
היה מסוג אחד-ועוד-אחד
כך שבכל הוראה למכונה,
בנוסף ל[קוד-הפעולה](#)
ולכתובת ה[אוֹפֵּרַנְדּ](#),
היתה כתובת נוספת שציינה היכן, על התוף המסתובב,
ממוקמת ההוראה הבאה.

בהשאלה לימינו,
כל פעולה הסתיימה בפקודה [GO TO](#)!
פַּטְמוּ בַּזֶּה את מיקטרתו של [פסקל](#) ועשנו.

מל אהב את ה-4000-RPC
משום שידע לכתוב עבורו [קוד אופטימלי](#):
כלומר, למקם הוראות על התוף
כך, כאשר הוראה נשלמה,
הבאה כבר הגיעה אל "הראש הקורא"
נגישה ליישום מיידי.
הייתה תוכנה שנועדה לעשות את הדבר הזה בדיוק,
"[אָסֶמְבְּלֶר](#) מייעל",[(#ref1)]
אך מל סירב להשתמש בה.

"לך תדע איפה זה יניח את הדברים",
הסביר, "כך שתיאלץ להשתמש בקבועים נפרדים."

רק לאחר זמן רב הבנתי את ההערה הזו באמת.
מאחר ומל הכיר את הערך המספרי
של כל הוראה
והִקצה בעצמו את הכתובות על התוף
כל הוראה שכתב יכולה הייתה להחשב
לקבוע מספרי.
כך יכול היה לקחת הוראת "חיבור", למשל,
ואם ערכה המספרי התאים,
להשתמש בה כּכוֹפֵל.
עריכת הקוד שלו הייתה מסובכת לכולם, זולתו.

השוויתי את האופטימיזציה הידנית של מל
עם קוד זהה שעבר עיסוי ב[אָסֶמְבְּלֶר](#) המייעל,
הקוד של מל תמיד רץ מהר יותר.
זה היה משום ש[עיצוב המעלה-מטה](#)
עוד לא הומצא אז
ומל ממילא לא היה משתמש בזה.
הדבר הראשון שכתב היו הלולאות הפנימיות של התוכנה שלו
כדי להעניק להן יתרון
בבחירת כתובות הזיכרון הראשונות בתוף.
האָסֶמְבְּלֶר המייעל לא היה מספיק מתוחכם כדי לעשות את זה.

מל מעולם גם לא כתב [לולאות השהיה](#),
אפילו כשה[פְלֵקסוֹרַייטֵר](#) העיקש
הזדקק להשהיה קלה בפלט האותיות כדי לעבוד כראוי.[(#flexowriter-cps)]
הוא פשוט מיקם הוראות על התוף
כך שהבאה בתור היתה בדיוק מאחורי הראש הקורא
כשהגיע תורה;
נדרש התוף לסיבוב שלם
כדי להגיע אליה.[(#mechanical-structure-vs-original-design)]
הוא טבע שם בלתי נשכח לתהליך הזה.
על אף ש"[אופטימום](#)" הוא מושג אבסולוטי,
כמו "ייחודי", הוא הפך למושג יחסי
שגור בדיבור:
"לא לגמרי [אופטימום](#)" או "פחות [אופטימום](#)"
או "לא ממש [אופטימום](#)".
מל כינה את אזורי ההשהיה המקסימלית
"[פסימום](#) קיצוני".

לאחר שסיים את תוכנת הבלאק ג'ק
בגרסה יציבה
("אפילו המאתחל אופטימלי",
אמר בגאווה)[(#mels-note-location-00000)]
קיבל דרישת תיקון ממחלקת המכירות.
התוכנה השתמשה במנגנון אלגנטי (אופטימלי)
להגרלת מספרים כדי לטרוף את "הקלפים" ולחלק את ה"חפיסה",
וכמה אנשי מכירות סברו כי המשחק הוגן מדי,
משום שמדי פעם הלקוחות הפסידו.
הם רצו שמל ישנה את התוכנה
כך שבאמצעות מתג במכונה
יוכלו להטות את המספרים לטובת הלקוח.

מל נרתע.
לתחושתו היה זה לא ישר בעליל
מה שנכון,
לכן סירב.
מנהל מחלקת המכירות דיבר עם מל,
כך גם הבוס הגדול, ואל הלחץ של הבוס
הצטרפו גם כמה מתכנתים.
לבסוף מל נכנע וכתב את הקוד,
אבל הוא הפך את התנאי,
וכשלחצו על המתג,
התוכנה רימתה, וניצחה בכל פעם.
מל היה מאושר
וטען שהוא אתי ברמת התת-מודע
ובשום אופן לא הסכים לתקן זאת.

לאחר שמל עזב את החברה למקום ע₪יר יותר
הבוס הגדול ביקש שאציץ בקוד
ואראה אם אוכל לתקן אותו.
בחוסר רצון נעתרתי לבקשתו.
לעקוב אחרי הקוד של מל היתה הרפתקה אמיתית.

תמיד הרגשתי שתכנות הוא אמנות
שערכה האמיתי יכול להיבחן רק בידי
אמן הבָּקִי בצפונותיהַ;
אורים ותומים נפלאים
חבויים מן העין האנושית, לעיתים לעד,
בשל עצם טבעו של התהליך.
אפשר ללמוד הרבה על אישיותו של אדם
רק מדפדוף בקוד שכתב
אפילו במספרים הקסדצימליים.
מל היה, אני מאמין, גאון שהקדים את זמנו.

ההלם הכי גדול שלי, כנראה, היה בגילוי
[לולאה](#) תמימה ללא [תנאי עצירה](#).
שום תנאי. כלום.
על פי ההיגיון הבריא זוהי [לולאה אינסופית](#)
בה התוכנה תרוץ במעגל, לעד, ללא הרף.
התוכנה הזו, לעומת זאת, חלפה בתוכה
ויצאה מצדה השני בבטחה.
נדרשו לי שבועיים כדי להבין איך.

מחשב ה-4000-RPC היה מצויד במתקן מאוד מודרני
בשם [אוֹגֵר](#)-מוֹנֶה
שאיפשר לתכנת לולאות
שעושות שימוש בהוראות עם היסט
בכל ריצה של הלולאה
המספר ב[אוֹגֵר](#)-מונה
התווסף לכתובת האופרנד בהוראה
כדי להצביע על
פיסת המידע הבאה בסדרה.
המתכנת היה צריך רק להוסיף 1 לערך השמור ב[אוֹגֵר](#)[(#index-register-1)]
בכל מעבר דרך הלולאה.
מל מעולם לא השתמש בו.

תחת זאת, הוא העתיק את ההוראה אל [אוֹגֵר](#) אחר במכונה
הוסיף 1 לרכיב הכתובת
ושמר את התוצאה במקומה המקורי בזכרון.[(#index-register-2)]
אז הריץ את ההוראה העדכנית
ישר מן ה[אוֹגֵר](#).
הלולאה נכתבה כך שזמן הריצה הנוסף
נלקח בחשבון –
מייד כשביצוע ההוראה הסתיים,
הבאה בתור הייתה כבר מונחת מתחת לראש הקריאה של התוף
מוכנה לריצה.
אבל בלולאה לא היה תנאי עצירה.

הרמז החיוני הגיע כאשר שמתי לב
שה[ביט](#) של ה[אוֹגֵר](#)-מונה,
ה[ביט](#) שבין הכתובת לבין קוד-הפעולה בהוראה,
היה דלוק[(#bit-binary-note)] –
אך מל לא השתמש ב[אוֹגֵר](#)-מונה,
והשאיר אותו מאופס תמיד.
כשראיתי את האור כמעט הסתנוורתי.

הוא מיקם את המידע שעליו עבד
סמוך לראש הזיכרון –
בכתובות הגדולות ביותר אליהן יכלה הוראה לפנות[(#rpc-4000-operand-address)] -
כך שלאחר שפריט המידע האחרונה טופל,
פעולת חיבור על כתובת ההוראה
הייתה גורמת לגלישתה.[(#numeric-overflow)]
העברת השארית הוסיפה 1[(#how-instructions-are-composed)]
לקוד-הפעולה ושינתה אותו לקוד-הפעולה הבא ברשימת ההוראות:
[הוראת דילוג](#).
מן הסתם, ההוראה הבאה כבר הייתה
בכתובת אפס,[(#rpc-4000-drum-memory-lowest-address)]
והתוכנה המשיכה קדימה באושר בדרכה.

לא שמרתי על קשר עם מל
אז איני יודע אם אי פעם נכנע ללחץ
השינויים ששטף את שיטות התכנות
מאז אותם ימים נשכחים.
אני מעדיף לחשוב שלא.
כך או כך,
התרשמתי מספיק כדי להפסיק לחפש
את הקוד הסורר,
ואמרתי לבוס שלא מצאתי כלום.
הוא לא היה מופתע.

כשעזבתי את החברה,
תוכנת הבלאק ג'ק עדיין רימתה
אם הפעלת את המתג הנכון,
וטוב שכך.
לא הרגשתי בנוח
להתעס-האק בקוד של מתכנת אמיתי.
